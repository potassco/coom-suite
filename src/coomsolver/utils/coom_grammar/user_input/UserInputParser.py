# Generated from UserInput.g4 by ANTLR 4.9.3
# encoding: utf-8
import sys
from io import StringIO

from antlr4 import *

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\65")
        buf.write("\u00c8\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\3\2\3\2\7\2\61")
        buf.write("\n\2\f\2\16\2\64\13\2\3\2\3\2\3\3\3\3\3\3\3\3\7\3<\n\3")
        buf.write("\f\3\16\3?\13\3\3\3\3\3\3\4\3\4\5\4E\n\4\3\5\3\5\3\5\3")
        buf.write("\5\3\5\3\6\3\6\5\6N\n\6\3\6\3\6\3\7\3\7\3\7\3\7\5\7V\n")
        buf.write("\7\3\b\5\bY\n\b\3\b\3\b\3\t\3\t\3\t\7\t`\n\t\f\t\16\t")
        buf.write("c\13\t\3\n\3\n\3\n\3\n\3\n\5\nj\n\n\3\n\3\n\5\nn\n\n\3")
        buf.write("\13\3\13\3\13\3\13\5\13t\n\13\5\13v\n\13\3\f\3\f\3\r\3")
        buf.write("\r\5\r|\n\r\3\16\3\16\3\17\3\17\3\20\3\20\3\20\7\20\u0085")
        buf.write("\n\20\f\20\16\20\u0088\13\20\3\21\3\21\3\21\7\21\u008d")
        buf.write("\n\21\f\21\16\21\u0090\13\21\3\22\3\22\3\22\7\22\u0095")
        buf.write("\n\22\f\22\16\22\u0098\13\22\3\23\3\23\3\23\7\23\u009d")
        buf.write("\n\23\f\23\16\23\u00a0\13\23\3\24\3\24\3\24\7\24\u00a5")
        buf.write("\n\24\f\24\16\24\u00a8\13\24\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\3\25\3\25\3\25\3\25\5\25\u00b4\n\25\3\26\3\26\3")
        buf.write("\26\3\26\3\26\7\26\u00bb\n\26\f\26\16\26\u00be\13\26\3")
        buf.write("\26\3\26\3\27\3\27\3\27\3\27\5\27\u00c6\n\27\3\27\2\2")
        buf.write('\30\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 "$&(*,\2\5')
        buf.write("\4\2\f\f./\4\2%%,-\4\2\7\7\23\35\2\u00cd\2\62\3\2\2\2")
        buf.write("\4\67\3\2\2\2\6D\3\2\2\2\bF\3\2\2\2\nK\3\2\2\2\fU\3\2")
        buf.write("\2\2\16X\3\2\2\2\20\\\3\2\2\2\22d\3\2\2\2\24u\3\2\2\2")
        buf.write("\26w\3\2\2\2\30{\3\2\2\2\32}\3\2\2\2\34\177\3\2\2\2\36")
        buf.write('\u0081\3\2\2\2 \u0089\3\2\2\2"\u0091\3\2\2\2$\u0099\3')
        buf.write("\2\2\2&\u00a1\3\2\2\2(\u00b3\3\2\2\2*\u00b5\3\2\2\2,\u00c5")
        buf.write("\3\2\2\2.\61\5\4\3\2/\61\5\6\4\2\60.\3\2\2\2\60/\3\2\2")
        buf.write("\2\61\64\3\2\2\2\62\60\3\2\2\2\62\63\3\2\2\2\63\65\3\2")
        buf.write("\2\2\64\62\3\2\2\2\65\66\7\2\2\3\66\3\3\2\2\2\678\7\3")
        buf.write("\2\289\5\20\t\29=\7\4\2\2:<\5\6\4\2;:\3\2\2\2<?\3\2\2")
        buf.write("\2=;\3\2\2\2=>\3\2\2\2>@\3\2\2\2?=\3\2\2\2@A\7\5\2\2A")
        buf.write("\5\3\2\2\2BE\5\b\5\2CE\5\n\6\2DB\3\2\2\2DC\3\2\2\2E\7")
        buf.write("\3\2\2\2FG\7\6\2\2GH\5\20\t\2HI\7\7\2\2IJ\5,\27\2J\t\3")
        buf.write("\2\2\2KM\7\b\2\2LN\7.\2\2ML\3\2\2\2MN\3\2\2\2NO\3\2\2")
        buf.write("\2OP\5\20\t\2P\13\3\2\2\2QV\5\16\b\2RV\5\26\f\2SV\7\t")
        buf.write("\2\2TV\7\n\2\2UQ\3\2\2\2UR\3\2\2\2US\3\2\2\2UT\3\2\2\2")
        buf.write("V\r\3\2\2\2WY\7\13\2\2XW\3\2\2\2XY\3\2\2\2YZ\3\2\2\2Z")
        buf.write("[\t\2\2\2[\17\3\2\2\2\\a\5\22\n\2]^\7\r\2\2^`\5\22\n\2")
        buf.write("_]\3\2\2\2`c\3\2\2\2a_\3\2\2\2ab\3\2\2\2b\21\3\2\2\2c")
        buf.write("a\3\2\2\2dm\5\26\f\2ef\7\16\2\2fi\5\24\13\2gh\7\17\2\2")
        buf.write("hj\5\24\13\2ig\3\2\2\2ij\3\2\2\2jk\3\2\2\2kl\7\20\2\2")
        buf.write("ln\3\2\2\2me\3\2\2\2mn\3\2\2\2n\23\3\2\2\2ov\7.\2\2ps")
        buf.write("\7\21\2\2qr\7\13\2\2rt\7.\2\2sq\3\2\2\2st\3\2\2\2tv\3")
        buf.write("\2\2\2uo\3\2\2\2up\3\2\2\2v\25\3\2\2\2wx\t\3\2\2x\27\3")
        buf.write("\2\2\2y|\7\22\2\2z|\b\r\1\2{y\3\2\2\2{z\3\2\2\2|\31\3")
        buf.write("\2\2\2}~\t\4\2\2~\33\3\2\2\2\177\u0080\5\36\20\2\u0080")
        buf.write("\35\3\2\2\2\u0081\u0086\5 \21\2\u0082\u0083\7\36\2\2\u0083")
        buf.write("\u0085\5 \21\2\u0084\u0082\3\2\2\2\u0085\u0088\3\2\2\2")
        buf.write("\u0086\u0084\3\2\2\2\u0086\u0087\3\2\2\2\u0087\37\3\2")
        buf.write('\2\2\u0088\u0086\3\2\2\2\u0089\u008e\5"\22\2\u008a\u008b')
        buf.write('\7\13\2\2\u008b\u008d\5"\22\2\u008c\u008a\3\2\2\2\u008d')
        buf.write("\u0090\3\2\2\2\u008e\u008c\3\2\2\2\u008e\u008f\3\2\2\2")
        buf.write("\u008f!\3\2\2\2\u0090\u008e\3\2\2\2\u0091\u0096\5$\23")
        buf.write("\2\u0092\u0093\7\37\2\2\u0093\u0095\5$\23\2\u0094\u0092")
        buf.write("\3\2\2\2\u0095\u0098\3\2\2\2\u0096\u0094\3\2\2\2\u0096")
        buf.write("\u0097\3\2\2\2\u0097#\3\2\2\2\u0098\u0096\3\2\2\2\u0099")
        buf.write("\u009e\5&\24\2\u009a\u009b\7 \2\2\u009b\u009d\5&\24\2")
        buf.write("\u009c\u009a\3\2\2\2\u009d\u00a0\3\2\2\2\u009e\u009c\3")
        buf.write("\2\2\2\u009e\u009f\3\2\2\2\u009f%\3\2\2\2\u00a0\u009e")
        buf.write("\3\2\2\2\u00a1\u00a6\5(\25\2\u00a2\u00a3\7!\2\2\u00a3")
        buf.write("\u00a5\5(\25\2\u00a4\u00a2\3\2\2\2\u00a5\u00a8\3\2\2\2")
        buf.write("\u00a6\u00a4\3\2\2\2\u00a6\u00a7\3\2\2\2\u00a7'\3\2\2")
        buf.write("\2\u00a8\u00a6\3\2\2\2\u00a9\u00aa\7\13\2\2\u00aa\u00b4")
        buf.write("\5(\25\2\u00ab\u00ac\7\36\2\2\u00ac\u00b4\5(\25\2\u00ad")
        buf.write('\u00ae\7"\2\2\u00ae\u00af\5\34\17\2\u00af\u00b0\7#\2')
        buf.write("\2\u00b0\u00b4\3\2\2\2\u00b1\u00b4\5*\26\2\u00b2\u00b4")
        buf.write("\5,\27\2\u00b3\u00a9\3\2\2\2\u00b3\u00ab\3\2\2\2\u00b3")
        buf.write("\u00ad\3\2\2\2\u00b3\u00b1\3\2\2\2\u00b3\u00b2\3\2\2\2")
        buf.write('\u00b4)\3\2\2\2\u00b5\u00b6\7%\2\2\u00b6\u00b7\7"\2\2')
        buf.write("\u00b7\u00bc\5\34\17\2\u00b8\u00b9\7$\2\2\u00b9\u00bb")
        buf.write("\5\34\17\2\u00ba\u00b8\3\2\2\2\u00bb\u00be\3\2\2\2\u00bc")
        buf.write("\u00ba\3\2\2\2\u00bc\u00bd\3\2\2\2\u00bd\u00bf\3\2\2\2")
        buf.write("\u00be\u00bc\3\2\2\2\u00bf\u00c0\7#\2\2\u00c0+\3\2\2\2")
        buf.write("\u00c1\u00c6\7\t\2\2\u00c2\u00c6\7\n\2\2\u00c3\u00c6\5")
        buf.write("\16\b\2\u00c4\u00c6\5\20\t\2\u00c5\u00c1\3\2\2\2\u00c5")
        buf.write("\u00c2\3\2\2\2\u00c5\u00c3\3\2\2\2\u00c5\u00c4\3\2\2\2")
        buf.write("\u00c6-\3\2\2\2\27\60\62=DMUXaimsu{\u0086\u008e\u0096")
        buf.write("\u009e\u00a6\u00b3\u00bc\u00c5")
        return buf.getvalue()


class UserInputParser(Parser):

    grammarFileName = "UserInput.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "'blockinput'",
        "'{'",
        "'}'",
        "'set'",
        "'='",
        "'add'",
        "'true'",
        "'false'",
        "'-'",
        "'\u221E'",
        "'.'",
        "'['",
        "'..'",
        "']'",
        "'last'",
        "';'",
        "'<'",
        "'<='",
        "'\u2264'",
        "'>'",
        "'>='",
        "'\u2265'",
        "'=='",
        "'!='",
        "'\u2260'",
        "'\u2287'",
        "'contains'",
        "'+'",
        "'*'",
        "'/'",
        "'^'",
        "'('",
        "')'",
        "','",
        "<INVALID>",
        "<INVALID>",
        "'behavior'",
        "'condition'",
        "'imply'",
        "'require'",
        "'default'",
    ]

    symbolicNames = [
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "FUNCTION",
        "TRIGONOMETRIC",
        "BEHAVIOR",
        "CONDITION",
        "IMPLY",
        "REQUIRE",
        "DEFAULT",
        "KEYWORD",
        "NAME",
        "INTEGER",
        "FLOATING",
        "TIMES",
        "HASHES",
        "NEWLINE",
        "WHITESPACE",
        "COMMENT",
        "MULTILINE_COMMENT",
    ]

    RULE_user_input = 0
    RULE_input_block = 1
    RULE_input_operation = 2
    RULE_set_value = 3
    RULE_add_instance = 4
    RULE_constant = 5
    RULE_floating = 6
    RULE_path = 7
    RULE_path_item = 8
    RULE_path_index = 9
    RULE_name = 10
    RULE_stmt_end = 11
    RULE_compare = 12
    RULE_formula = 13
    RULE_formula_add = 14
    RULE_formula_sub = 15
    RULE_formula_mul = 16
    RULE_formula_div = 17
    RULE_formula_pow = 18
    RULE_formula_sign = 19
    RULE_formula_func = 20
    RULE_formula_atom = 21

    ruleNames = [
        "user_input",
        "input_block",
        "input_operation",
        "set_value",
        "add_instance",
        "constant",
        "floating",
        "path",
        "path_item",
        "path_index",
        "name",
        "stmt_end",
        "compare",
        "formula",
        "formula_add",
        "formula_sub",
        "formula_mul",
        "formula_div",
        "formula_pow",
        "formula_sign",
        "formula_func",
        "formula_atom",
    ]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    T__3 = 4
    T__4 = 5
    T__5 = 6
    T__6 = 7
    T__7 = 8
    T__8 = 9
    T__9 = 10
    T__10 = 11
    T__11 = 12
    T__12 = 13
    T__13 = 14
    T__14 = 15
    T__15 = 16
    T__16 = 17
    T__17 = 18
    T__18 = 19
    T__19 = 20
    T__20 = 21
    T__21 = 22
    T__22 = 23
    T__23 = 24
    T__24 = 25
    T__25 = 26
    T__26 = 27
    T__27 = 28
    T__28 = 29
    T__29 = 30
    T__30 = 31
    T__31 = 32
    T__32 = 33
    T__33 = 34
    FUNCTION = 35
    TRIGONOMETRIC = 36
    BEHAVIOR = 37
    CONDITION = 38
    IMPLY = 39
    REQUIRE = 40
    DEFAULT = 41
    KEYWORD = 42
    NAME = 43
    INTEGER = 44
    FLOATING = 45
    TIMES = 46
    HASHES = 47
    NEWLINE = 48
    WHITESPACE = 49
    COMMENT = 50
    MULTILINE_COMMENT = 51

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    def wasNewline(self):
        for index in reversed(range(self.getCurrentToken().tokenIndex)):
            # stop on default channel
            token = self.getTokenStream().get(index)
            if token.channel == 0:
                break

            # if the token is blank and contains newline, we found it
            if len(token.text) == 0:
                continue
            if token.text.startswith("\n") or token.text.startswith("\r"):
                return True

        return False

    class User_inputContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(UserInputParser.EOF, 0)

        def input_block(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Input_blockContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Input_blockContext, i)

        def input_operation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Input_operationContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Input_operationContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_user_input

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUser_input"):
                listener.enterUser_input(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUser_input"):
                listener.exitUser_input(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUser_input"):
                return visitor.visitUser_input(self)
            else:
                return visitor.visitChildren(self)

    def user_input(self):

        localctx = UserInputParser.User_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_user_input)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 48
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3F) == 0 and (
                (1 << _la) & ((1 << UserInputParser.T__0) | (1 << UserInputParser.T__3) | (1 << UserInputParser.T__5))
            ) != 0:
                self.state = 46
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [UserInputParser.T__0]:
                    self.state = 44
                    self.input_block()
                elif token in [UserInputParser.T__3, UserInputParser.T__5]:
                    self.state = 45
                    self.input_operation()
                else:
                    raise NoViableAltException(self)

                self.state = 50
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 51
            self.match(UserInputParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Input_blockContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def path(self):
            return self.getTypedRuleContext(UserInputParser.PathContext, 0)

        def input_operation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Input_operationContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Input_operationContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_input_block

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInput_block"):
                listener.enterInput_block(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInput_block"):
                listener.exitInput_block(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInput_block"):
                return visitor.visitInput_block(self)
            else:
                return visitor.visitChildren(self)

    def input_block(self):

        localctx = UserInputParser.Input_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_input_block)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.match(UserInputParser.T__0)
            self.state = 54
            self.path()
            self.state = 55
            self.match(UserInputParser.T__1)
            self.state = 59
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == UserInputParser.T__3 or _la == UserInputParser.T__5:
                self.state = 56
                self.input_operation()
                self.state = 61
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 62
            self.match(UserInputParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Input_operationContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def set_value(self):
            return self.getTypedRuleContext(UserInputParser.Set_valueContext, 0)

        def add_instance(self):
            return self.getTypedRuleContext(UserInputParser.Add_instanceContext, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_input_operation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInput_operation"):
                listener.enterInput_operation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInput_operation"):
                listener.exitInput_operation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInput_operation"):
                return visitor.visitInput_operation(self)
            else:
                return visitor.visitChildren(self)

    def input_operation(self):

        localctx = UserInputParser.Input_operationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_input_operation)
        try:
            self.state = 66
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UserInputParser.T__3]:
                self.enterOuterAlt(localctx, 1)
                self.state = 64
                self.set_value()
            elif token in [UserInputParser.T__5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 65
                self.add_instance()
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Set_valueContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.op = None  # Token

        def path(self):
            return self.getTypedRuleContext(UserInputParser.PathContext, 0)

        def formula_atom(self):
            return self.getTypedRuleContext(UserInputParser.Formula_atomContext, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_set_value

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSet_value"):
                listener.enterSet_value(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSet_value"):
                listener.exitSet_value(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSet_value"):
                return visitor.visitSet_value(self)
            else:
                return visitor.visitChildren(self)

    def set_value(self):

        localctx = UserInputParser.Set_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_set_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            localctx.op = self.match(UserInputParser.T__3)
            self.state = 69
            self.path()
            self.state = 70
            self.match(UserInputParser.T__4)
            self.state = 71
            self.formula_atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Add_instanceContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.op = None  # Token

        def path(self):
            return self.getTypedRuleContext(UserInputParser.PathContext, 0)

        def INTEGER(self):
            return self.getToken(UserInputParser.INTEGER, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_add_instance

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAdd_instance"):
                listener.enterAdd_instance(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAdd_instance"):
                listener.exitAdd_instance(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAdd_instance"):
                return visitor.visitAdd_instance(self)
            else:
                return visitor.visitChildren(self)

    def add_instance(self):

        localctx = UserInputParser.Add_instanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_add_instance)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            localctx.op = self.match(UserInputParser.T__5)
            self.state = 75
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == UserInputParser.INTEGER:
                self.state = 74
                self.match(UserInputParser.INTEGER)

            self.state = 77
            self.path()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def floating(self):
            return self.getTypedRuleContext(UserInputParser.FloatingContext, 0)

        def name(self):
            return self.getTypedRuleContext(UserInputParser.NameContext, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_constant

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstant"):
                listener.enterConstant(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstant"):
                listener.exitConstant(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstant"):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)

    def constant(self):

        localctx = UserInputParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_constant)
        try:
            self.state = 83
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UserInputParser.T__8, UserInputParser.T__9, UserInputParser.INTEGER, UserInputParser.FLOATING]:
                self.enterOuterAlt(localctx, 1)
                self.state = 79
                self.floating()
            elif token in [UserInputParser.FUNCTION, UserInputParser.KEYWORD, UserInputParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 80
                self.name()
            elif token in [UserInputParser.T__6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 81
                self.match(UserInputParser.T__6)
            elif token in [UserInputParser.T__7]:
                self.enterOuterAlt(localctx, 4)
                self.state = 82
                self.match(UserInputParser.T__7)
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FloatingContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOATING(self):
            return self.getToken(UserInputParser.FLOATING, 0)

        def INTEGER(self):
            return self.getToken(UserInputParser.INTEGER, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_floating

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFloating"):
                listener.enterFloating(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFloating"):
                listener.exitFloating(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFloating"):
                return visitor.visitFloating(self)
            else:
                return visitor.visitChildren(self)

    def floating(self):

        localctx = UserInputParser.FloatingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_floating)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == UserInputParser.T__8:
                self.state = 85
                self.match(UserInputParser.T__8)

            self.state = 88
            _la = self._input.LA(1)
            if not (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << UserInputParser.T__9)
                            | (1 << UserInputParser.INTEGER)
                            | (1 << UserInputParser.FLOATING)
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PathContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def path_item(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Path_itemContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Path_itemContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_path

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPath"):
                listener.enterPath(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPath"):
                listener.exitPath(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPath"):
                return visitor.visitPath(self)
            else:
                return visitor.visitChildren(self)

    def path(self):

        localctx = UserInputParser.PathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_path)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self.path_item()
            self.state = 95
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == UserInputParser.T__10:
                self.state = 91
                self.match(UserInputParser.T__10)
                self.state = 92
                self.path_item()
                self.state = 97
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Path_itemContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(UserInputParser.NameContext, 0)

        def path_index(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Path_indexContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Path_indexContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_path_item

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPath_item"):
                listener.enterPath_item(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPath_item"):
                listener.exitPath_item(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPath_item"):
                return visitor.visitPath_item(self)
            else:
                return visitor.visitChildren(self)

    def path_item(self):

        localctx = UserInputParser.Path_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_path_item)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.name()
            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == UserInputParser.T__11:
                self.state = 99
                self.match(UserInputParser.T__11)
                self.state = 100
                self.path_index()
                self.state = 103
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == UserInputParser.T__12:
                    self.state = 101
                    self.match(UserInputParser.T__12)
                    self.state = 102
                    self.path_index()

                self.state = 105
                self.match(UserInputParser.T__13)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Path_indexContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(UserInputParser.INTEGER, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_path_index

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPath_index"):
                listener.enterPath_index(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPath_index"):
                listener.exitPath_index(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPath_index"):
                return visitor.visitPath_index(self)
            else:
                return visitor.visitChildren(self)

    def path_index(self):

        localctx = UserInputParser.Path_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_path_index)
        self._la = 0  # Token type
        try:
            self.state = 115
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UserInputParser.INTEGER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 109
                self.match(UserInputParser.INTEGER)
            elif token in [UserInputParser.T__14]:
                self.enterOuterAlt(localctx, 2)
                self.state = 110
                self.match(UserInputParser.T__14)
                self.state = 113
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == UserInputParser.T__8:
                    self.state = 111
                    self.match(UserInputParser.T__8)
                    self.state = 112
                    self.match(UserInputParser.INTEGER)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NameContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(UserInputParser.NAME, 0)

        def FUNCTION(self):
            return self.getToken(UserInputParser.FUNCTION, 0)

        def KEYWORD(self):
            return self.getToken(UserInputParser.KEYWORD, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterName"):
                listener.enterName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitName"):
                listener.exitName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitName"):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)

    def name(self):

        localctx = UserInputParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_name)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            _la = self._input.LA(1)
            if not (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << UserInputParser.FUNCTION)
                            | (1 << UserInputParser.KEYWORD)
                            | (1 << UserInputParser.NAME)
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Stmt_endContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return UserInputParser.RULE_stmt_end

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStmt_end"):
                listener.enterStmt_end(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStmt_end"):
                listener.exitStmt_end(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStmt_end"):
                return visitor.visitStmt_end(self)
            else:
                return visitor.visitChildren(self)

    def stmt_end(self):

        localctx = UserInputParser.Stmt_endContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_stmt_end)
        try:
            self.state = 121
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UserInputParser.T__15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 119
                self.match(UserInputParser.T__15)
            elif token in [UserInputParser.EOF]:
                self.enterOuterAlt(localctx, 2)
                self.wasNewline()
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompareContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return UserInputParser.RULE_compare

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompare"):
                listener.enterCompare(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompare"):
                listener.exitCompare(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompare"):
                return visitor.visitCompare(self)
            else:
                return visitor.visitChildren(self)

    def compare(self):

        localctx = UserInputParser.CompareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_compare)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            _la = self._input.LA(1)
            if not (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << UserInputParser.T__4)
                            | (1 << UserInputParser.T__16)
                            | (1 << UserInputParser.T__17)
                            | (1 << UserInputParser.T__18)
                            | (1 << UserInputParser.T__19)
                            | (1 << UserInputParser.T__20)
                            | (1 << UserInputParser.T__21)
                            | (1 << UserInputParser.T__22)
                            | (1 << UserInputParser.T__23)
                            | (1 << UserInputParser.T__24)
                            | (1 << UserInputParser.T__25)
                            | (1 << UserInputParser.T__26)
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FormulaContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formula_add(self):
            return self.getTypedRuleContext(UserInputParser.Formula_addContext, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula"):
                listener.enterFormula(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula"):
                listener.exitFormula(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula"):
                return visitor.visitFormula(self)
            else:
                return visitor.visitChildren(self)

    def formula(self):

        localctx = UserInputParser.FormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.formula_add()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_addContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_sub(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Formula_subContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Formula_subContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula_add

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_add"):
                listener.enterFormula_add(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_add"):
                listener.exitFormula_add(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_add"):
                return visitor.visitFormula_add(self)
            else:
                return visitor.visitChildren(self)

    def formula_add(self):

        localctx = UserInputParser.Formula_addContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_formula_add)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.formula_sub()
            self.state = 132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == UserInputParser.T__27:
                self.state = 128
                localctx.operator = self.match(UserInputParser.T__27)
                self.state = 129
                self.formula_sub()
                self.state = 134
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_subContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_mul(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Formula_mulContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Formula_mulContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula_sub

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_sub"):
                listener.enterFormula_sub(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_sub"):
                listener.exitFormula_sub(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_sub"):
                return visitor.visitFormula_sub(self)
            else:
                return visitor.visitChildren(self)

    def formula_sub(self):

        localctx = UserInputParser.Formula_subContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_formula_sub)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.formula_mul()
            self.state = 140
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == UserInputParser.T__8:
                self.state = 136
                localctx.operator = self.match(UserInputParser.T__8)
                self.state = 137
                self.formula_mul()
                self.state = 142
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_mulContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_div(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Formula_divContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Formula_divContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula_mul

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_mul"):
                listener.enterFormula_mul(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_mul"):
                listener.exitFormula_mul(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_mul"):
                return visitor.visitFormula_mul(self)
            else:
                return visitor.visitChildren(self)

    def formula_mul(self):

        localctx = UserInputParser.Formula_mulContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_formula_mul)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.formula_div()
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == UserInputParser.T__28:
                self.state = 144
                localctx.operator = self.match(UserInputParser.T__28)
                self.state = 145
                self.formula_div()
                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_divContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_pow(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Formula_powContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Formula_powContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula_div

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_div"):
                listener.enterFormula_div(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_div"):
                listener.exitFormula_div(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_div"):
                return visitor.visitFormula_div(self)
            else:
                return visitor.visitChildren(self)

    def formula_div(self):

        localctx = UserInputParser.Formula_divContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_formula_div)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.formula_pow()
            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == UserInputParser.T__29:
                self.state = 152
                localctx.operator = self.match(UserInputParser.T__29)
                self.state = 153
                self.formula_pow()
                self.state = 158
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_powContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_sign(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.Formula_signContext)
            else:
                return self.getTypedRuleContext(UserInputParser.Formula_signContext, i)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula_pow

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_pow"):
                listener.enterFormula_pow(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_pow"):
                listener.exitFormula_pow(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_pow"):
                return visitor.visitFormula_pow(self)
            else:
                return visitor.visitChildren(self)

    def formula_pow(self):

        localctx = UserInputParser.Formula_powContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_formula_pow)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            self.formula_sign()
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == UserInputParser.T__30:
                self.state = 160
                localctx.operator = self.match(UserInputParser.T__30)
                self.state = 161
                self.formula_sign()
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_signContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.neg = None  # Formula_signContext

        def formula_sign(self):
            return self.getTypedRuleContext(UserInputParser.Formula_signContext, 0)

        def formula(self):
            return self.getTypedRuleContext(UserInputParser.FormulaContext, 0)

        def formula_func(self):
            return self.getTypedRuleContext(UserInputParser.Formula_funcContext, 0)

        def formula_atom(self):
            return self.getTypedRuleContext(UserInputParser.Formula_atomContext, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula_sign

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_sign"):
                listener.enterFormula_sign(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_sign"):
                listener.exitFormula_sign(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_sign"):
                return visitor.visitFormula_sign(self)
            else:
                return visitor.visitChildren(self)

    def formula_sign(self):

        localctx = UserInputParser.Formula_signContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_formula_sign)
        try:
            self.state = 177
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 18, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 167
                self.match(UserInputParser.T__8)
                self.state = 168
                localctx.neg = self.formula_sign()

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 169
                self.match(UserInputParser.T__27)
                self.state = 170
                self.formula_sign()

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 171
                self.match(UserInputParser.T__31)
                self.state = 172
                self.formula()
                self.state = 173
                self.match(UserInputParser.T__32)

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 175
                self.formula_func()

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 176
                self.formula_atom()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_funcContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.fun = None  # Token

        def formula(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(UserInputParser.FormulaContext)
            else:
                return self.getTypedRuleContext(UserInputParser.FormulaContext, i)

        def FUNCTION(self):
            return self.getToken(UserInputParser.FUNCTION, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula_func

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_func"):
                listener.enterFormula_func(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_func"):
                listener.exitFormula_func(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_func"):
                return visitor.visitFormula_func(self)
            else:
                return visitor.visitChildren(self)

    def formula_func(self):

        localctx = UserInputParser.Formula_funcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_formula_func)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            localctx.fun = self.match(UserInputParser.FUNCTION)
            self.state = 180
            self.match(UserInputParser.T__31)
            self.state = 181
            self.formula()
            self.state = 186
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == UserInputParser.T__33:
                self.state = 182
                self.match(UserInputParser.T__33)
                self.state = 183
                self.formula()
                self.state = 188
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 189
            self.match(UserInputParser.T__32)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_atomContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.atom_true = None  # Token
            self.atom_false = None  # Token
            self.atom_num = None  # FloatingContext
            self.atom_path = None  # PathContext

        def floating(self):
            return self.getTypedRuleContext(UserInputParser.FloatingContext, 0)

        def path(self):
            return self.getTypedRuleContext(UserInputParser.PathContext, 0)

        def getRuleIndex(self):
            return UserInputParser.RULE_formula_atom

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_atom"):
                listener.enterFormula_atom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_atom"):
                listener.exitFormula_atom(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_atom"):
                return visitor.visitFormula_atom(self)
            else:
                return visitor.visitChildren(self)

    def formula_atom(self):

        localctx = UserInputParser.Formula_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_formula_atom)
        try:
            self.state = 195
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UserInputParser.T__6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 191
                localctx.atom_true = self.match(UserInputParser.T__6)
            elif token in [UserInputParser.T__7]:
                self.enterOuterAlt(localctx, 2)
                self.state = 192
                localctx.atom_false = self.match(UserInputParser.T__7)
            elif token in [
                UserInputParser.T__8,
                UserInputParser.T__9,
                UserInputParser.INTEGER,
                UserInputParser.FLOATING,
            ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 193
                localctx.atom_num = self.floating()
            elif token in [UserInputParser.FUNCTION, UserInputParser.KEYWORD, UserInputParser.NAME]:
                self.enterOuterAlt(localctx, 4)
                self.state = 194
                localctx.atom_path = self.path()
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
